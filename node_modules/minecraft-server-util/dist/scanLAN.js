"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const dgram_1 = __importDefault(require("dgram"));
const util_1 = require("util");
const Description_1 = __importDefault(require("./structure/Description"));
const pattern = /\[MOTD\](.+)?(?=\[\/MOTD\])\[\/MOTD\]\[AD\](\d+)\[\/AD\]/;
const decoder = new util_1.TextDecoder('utf-8');
function applyDefaultOptions(options) {
    // Apply the provided options on the default options
    return Object.assign({
        scanTime: 1000 * 5
    }, options);
}
/**
 * Scans the local area network for any Minecraft worlds.
 * @param {ScanLANOptions} [options] The options to use when scanning LAN
 * @returns {Promise<ScanLANResponse>} The response of the scan
 * @async
 */
function scanLAN(options) {
    return __awaiter(this, void 0, void 0, function* () {
        // Applies the provided options on top of the default options
        const opts = applyDefaultOptions(options);
        // Assert that the arguments are the correct type and format
        assert_1.default(typeof options === 'object' || typeof options === 'undefined', `Expected 'options' to be an object or undefined, got ${typeof options}`);
        assert_1.default(typeof opts === 'object', `Expected 'options' to be an object, got ${typeof opts}`);
        assert_1.default(typeof opts.scanTime === 'number', `Expected 'options.scanTime' to be a number, got ${typeof opts.scanTime}`);
        assert_1.default(opts.scanTime >= 1500, `Expected 'options.scanTime' to be greater than or equal to 1500, got ${opts.scanTime}`);
        // Create a list of servers that the socket will append to
        const servers = [];
        // Create a new UDP socket and listen for messages
        const socket = dgram_1.default.createSocket('udp4');
        // Wait for messages being broadcased
        socket.on('message', (message, info) => {
            var _a, _b;
            const text = decoder.decode(message);
            // Ensure that the text sent to the scan port matches the "Open to LAN" format
            if (pattern.test(text)) {
                const match = text.match(pattern);
                if (!match)
                    return;
                // Parse the port out of the matched text
                const port = parseInt(match[2]);
                if (isNaN(port))
                    return;
                if (servers.length > 0) {
                    // Check if the server is already in the servers list to prevent duplicates for long scan times
                    for (let i = 0, j = servers.length; i < j; i++) {
                        // If the server already exists in the list, exit the loop
                        if (servers[i].host === info.address && servers[i].port === port)
                            break;
                        // Wait until the last value has been scanned
                        if (i + 1 !== j)
                            continue;
                        // Add the server to the server list
                        servers.push({
                            host: info.address,
                            port,
                            description: new Description_1.default((_a = match[1]) !== null && _a !== void 0 ? _a : '')
                        });
                    }
                }
                else {
                    // Add the server to the servers list
                    servers.push({
                        host: info.address,
                        port,
                        description: new Description_1.default((_b = match[1]) !== null && _b !== void 0 ? _b : '')
                    });
                }
            }
        });
        // Bind to the 4445 port which is used for receiving and broadcasting "Open to LAN" worlds
        socket.bind(4445, () => {
            socket.addMembership('224.0.2.60');
        });
        // Return the timeout promise that will resolve when the scan time is up
        return new Promise((resolve) => setTimeout(() => {
            resolve({ servers });
            socket.close();
        }, opts.scanTime));
    });
}
exports.default = scanLAN;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbkxBTi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zY2FuTEFOLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQTRCO0FBQzVCLGtEQUEwQjtBQUMxQiwrQkFBbUM7QUFDbkMsMEVBQWtEO0FBSWxELE1BQU0sT0FBTyxHQUFHLDBEQUEwRCxDQUFDO0FBQzNFLE1BQU0sT0FBTyxHQUFHLElBQUksa0JBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUV6QyxTQUFTLG1CQUFtQixDQUFDLE9BQXdCO0lBQ3BELG9EQUFvRDtJQUNwRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDcEIsUUFBUSxFQUFFLElBQUksR0FBRyxDQUFDO0tBQ1UsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFlLE9BQU8sQ0FBQyxPQUF3Qjs7UUFDOUMsNkRBQTZEO1FBQzdELE1BQU0sSUFBSSxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTFDLDREQUE0RDtRQUM1RCxnQkFBTSxDQUFDLE9BQU8sT0FBTyxLQUFLLFFBQVEsSUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLEVBQUUsd0RBQXdELE9BQU8sT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNoSixnQkFBTSxDQUFDLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRSwyQ0FBMkMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQzNGLGdCQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRSxtREFBbUQsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNySCxnQkFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFLHdFQUF3RSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUV2SCwwREFBMEQ7UUFDMUQsTUFBTSxPQUFPLEdBQW9CLEVBQUUs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